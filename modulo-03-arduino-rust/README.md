# üîß M√≥dulo 3: Arduino com Rust (no_std)

## üéØ **Objetivos de Aprendizagem Acad√™mica**

Ao final deste m√≥dulo, voc√™ ser√° capaz de:
- ‚úÖ Configurar ambiente de desenvolvimento Rust para Arduino
- ‚úÖ Trabalhar com `no_std` e bare metal programming
- ‚úÖ Implementar HAL (Hardware Abstraction Layer)
- ‚úÖ Desenvolver sistemas de interrup√ß√£o e timers
- ‚úÖ Criar protocolos de comunica√ß√£o (I2C, SPI, Serial)
- ‚úÖ Realizar projetos de pesquisa com Arduino e Rust

## üìö **Conte√∫do Te√≥rico Acad√™mico**

### **3.1 Introdu√ß√£o ao no_std**

#### **Conceitos Fundamentais**
```rust
#![no_std]  // Sem biblioteca padr√£o
#![no_main] // Sem fun√ß√£o main padr√£o
#![feature(start)] // Feature para entry point

// Sem heap allocation
// Sem std::collections
// Sem std::thread
// Sem std::sync
```

#### **Vantagens do no_std**
- **Controle Total**: Acesso direto ao hardware
- **Previsibilidade**: Sem garbage collection
- **Performance**: Sem overhead de runtime
- **Seguran√ßa**: Memory safety mantida

### **3.2 Hardware Abstraction Layer (HAL)**

#### **Estrutura do HAL**
```rust
// hal.rs
pub trait DigitalPin {
    type Error;
    
    fn set_high(&mut self) -> Result<(), Self::Error>;
    fn set_low(&mut self) -> Result<(), Self::Error>;
    fn is_high(&self) -> Result<bool, Self::Error>;
    fn is_low(&self) -> Result<bool, Self::Error>;
}

pub trait AnalogPin {
    type Error;
    
    fn read(&mut self) -> Result<u16, Self::Error>;
}

pub trait Serial {
    type Error;
    
    fn write(&mut self, data: &[u8]) -> Result<(), Self::Error>;
    fn read(&mut self, buffer: &mut [u8]) -> Result<usize, Self::Error>;
}
```

#### **Implementa√ß√£o para Arduino**
```rust
// arduino_hal.rs
use arduino_hal::prelude::*;
use arduino_hal::port::mode::Output;
use arduino_hal::port::Pin;

pub struct ArduinoDigitalPin {
    pin: Pin<Output, arduino_hal::port::mode::Output>,
}

impl DigitalPin for ArduinoDigitalPin {
    type Error = ();
    
    fn set_high(&mut self) -> Result<(), Self::Error> {
        self.pin.set_high();
        Ok(())
    }
    
    fn set_low(&mut self) -> Result<(), Self::Error> {
        self.pin.set_low();
        Ok(())
    }
    
    fn is_high(&self) -> Result<bool, Self::Error> {
        Ok(self.pin.is_set_high())
    }
    
    fn is_low(&self) -> Result<bool, Self::Error> {
        Ok(self.pin.is_set_low())
    }
}
```

### **3.3 Sistema de Interrup√ß√µes**

#### **Configura√ß√£o de Interrup√ß√µes**
```rust
// interrupts.rs
use arduino_hal::interrupt;
use core::sync::atomic::{AtomicBool, Ordering};

static INTERRUPT_FLAG: AtomicBool = AtomicBool::new(false);

#[interrupt]
fn INT0() {
    // Interrup√ß√£o externa no pino 2
    INTERRUPT_FLAG.store(true, Ordering::Relaxed);
}

pub struct InterruptManager {
    interrupt_enabled: bool,
}

impl InterruptManager {
    pub fn new() -> Self {
        Self {
            interrupt_enabled: false,
        }
    }
    
    pub fn enable_external_interrupt(&mut self, pin: u8) {
        // Configurar interrup√ß√£o externa
        arduino_hal::interrupt::enable();
        self.interrupt_enabled = true;
    }
    
    pub fn check_interrupt_flag(&self) -> bool {
        INTERRUPT_FLAG.load(Ordering::Relaxed)
    }
    
    pub fn clear_interrupt_flag(&mut self) {
        INTERRUPT_FLAG.store(false, Ordering::Relaxed);
    }
}
```

## üíª **Exemplos Pr√°ticos Acad√™micos**

### **Exemplo 1: Sistema de Monitoramento Ambiental**

**Objetivo de Pesquisa**: Monitorar temperatura, umidade e qualidade do ar em tempo real

```rust
// environmental_monitor.rs
#![no_std]
#![no_main]

use arduino_hal::prelude::*;
use panic_halt as _;

pub struct EnvironmentalMonitor {
    temperature_sensor: arduino_hal::adc::AdcChannel,
    humidity_sensor: arduino_hal::adc::AdcChannel,
    air_quality_sensor: arduino_hal::adc::AdcChannel,
    serial: arduino_hal::Usart<arduino_hal::pac::USART0>,
    led_status: arduino_hal::port::Pin<arduino_hal::port::mode::Output>,
}

impl EnvironmentalMonitor {
    pub fn new() -> Self {
        let dp = arduino_hal::Peripherals::take().unwrap();
        let pins = arduino_hal::pins!(dp);
        
        let mut adc = arduino_hal::Adc::new(dp.ADC, arduino_hal::DefaultClock);
        let temperature_sensor = pins.a0.into_analog_input(&mut adc);
        let humidity_sensor = pins.a1.into_analog_input(&mut adc);
        let air_quality_sensor = pins.a2.into_analog_input(&mut adc);
        
        let serial = arduino_hal::Usart::new(
            dp.USART0,
            pins.d0,
            pins.d1.into_output(),
            9600.into_baudrate(),
        );
        
        let led_status = pins.d13.into_output();
        
        Self {
            temperature_sensor,
            humidity_sensor,
            air_quality_sensor,
            serial,
            led_status,
        }
    }
    
    pub fn read_sensors(&mut self) -> SensorData {
        let temp_raw = self.temperature_sensor.analog_read(&mut adc);
        let humidity_raw = self.humidity_sensor.analog_read(&mut adc);
        let air_quality_raw = self.air_quality_sensor.analog_read(&mut adc);
        
        SensorData {
            temperature: self.convert_temperature(temp_raw),
            humidity: self.convert_humidity(humidity_raw),
            air_quality: self.convert_air_quality(air_quality_raw),
        }
    }
    
    fn convert_temperature(&self, raw: u16) -> f32 {
        // Convers√£o ADC para temperatura (exemplo)
        (raw as f32 * 5.0 / 1024.0 - 0.5) * 100.0
    }
    
    fn convert_humidity(&self, raw: u16) -> f32 {
        // Convers√£o ADC para umidade (exemplo)
        raw as f32 * 100.0 / 1024.0
    }
    
    fn convert_air_quality(&self, raw: u16) -> f32 {
        // Convers√£o ADC para qualidade do ar (exemplo)
        raw as f32 * 500.0 / 1024.0
    }
    
    pub fn send_data(&mut self, data: &SensorData) {
        let message = format!(
            "T:{:.1}C,H:{:.1}%,AQ:{:.1}\n",
            data.temperature,
            data.humidity,
            data.air_quality
        );
        
        for byte in message.bytes() {
            nb::block!(self.serial.write(byte)).unwrap();
        }
    }
    
    pub fn update_status_led(&mut self, status: bool) {
        if status {
            self.led_status.set_high();
        } else {
            self.led_status.set_low();
        }
    }
}

pub struct SensorData {
    pub temperature: f32,
    pub humidity: f32,
    pub air_quality: f32,
}

#[arduino_hal::entry]
fn main() -> ! {
    let mut monitor = EnvironmentalMonitor::new();
    let mut last_reading = 0u32;
    
    loop {
        let current_time = arduino_hal::time::millis();
        
        // Ler sensores a cada 5 segundos
        if current_time - last_reading > 5000 {
            let sensor_data = monitor.read_sensors();
            monitor.send_data(&sensor_data);
            
            // Atualizar LED de status
            let status = sensor_data.temperature > 25.0 && sensor_data.humidity < 80.0;
            monitor.update_status_led(status);
            
            last_reading = current_time;
        }
        
        arduino_hal::delay_ms(100);
    }
}
```

### **Exemplo 2: Sistema de Controle com PID**

**Objetivo de Pesquisa**: Implementar controlador PID para temperatura

```rust
// pid_controller.rs
pub struct PIDController {
    kp: f32,    // Proporcional
    ki: f32,    // Integral
    kd: f32,    // Derivativo
    integral: f32,
    previous_error: f32,
    last_time: u32,
}

impl PIDController {
    pub fn new(kp: f32, ki: f32, kd: f32) -> Self {
        Self {
            kp,
            ki,
            kd,
            integral: 0.0,
            previous_error: 0.0,
            last_time: 0,
        }
    }
    
    pub fn calculate(&mut self, setpoint: f32, current_value: f32, current_time: u32) -> f32 {
        let error = setpoint - current_value;
        let dt = (current_time - self.last_time) as f32 / 1000.0; // Converter para segundos
        
        if dt > 0.0 {
            // Termo proporcional
            let proportional = self.kp * error;
            
            // Termo integral
            self.integral += error * dt;
            let integral = self.ki * self.integral;
            
            // Termo derivativo
            let derivative = if dt > 0.0 {
                self.kd * (error - self.previous_error) / dt
            } else {
                0.0
            };
            
            let output = proportional + integral + derivative;
            
            // Atualizar para pr√≥xima itera√ß√£o
            self.previous_error = error;
            self.last_time = current_time;
            
            // Limitar sa√≠da
            output.max(0.0).min(255.0)
        } else {
            0.0
        }
    }
}

// Sistema de controle de temperatura
pub struct TemperatureController {
    pid: PIDController,
    heater_pin: arduino_hal::port::Pin<arduino_hal::port::mode::Output>,
    temperature_sensor: arduino_hal::adc::AdcChannel,
    target_temperature: f32,
}

impl TemperatureController {
    pub fn new(
        heater_pin: arduino_hal::port::Pin<arduino_hal::port::mode::Output>,
        temperature_sensor: arduino_hal::adc::AdcChannel,
        kp: f32, ki: f32, kd: f32,
    ) -> Self {
        Self {
            pid: PIDController::new(kp, ki, kd),
            heater_pin,
            temperature_sensor,
            target_temperature: 25.0,
        }
    }
    
    pub fn set_target_temperature(&mut self, temperature: f32) {
        self.target_temperature = temperature;
    }
    
    pub fn update(&mut self, current_time: u32) -> f32 {
        let current_temp = self.read_temperature();
        let pid_output = self.pid.calculate(
            self.target_temperature,
            current_temp,
            current_time
        );
        
        // Controlar aquecedor via PWM
        self.control_heater(pid_output);
        
        current_temp
    }
    
    fn read_temperature(&self) -> f32 {
        let raw = self.temperature_sensor.analog_read(&mut adc);
        // Convers√£o espec√≠fica do sensor
        (raw as f32 * 5.0 / 1024.0 - 0.5) * 100.0
    }
    
    fn control_heater(&mut self, power: f32) {
        // Implementar controle PWM do aquecedor
        let pwm_value = (power * 255.0 / 100.0) as u8;
        // Configurar PWM no pino do aquecedor
    }
}
```

### **Exemplo 3: Comunica√ß√£o I2C com Sensores**

**Objetivo de Pesquisa**: Implementar protocolo I2C para m√∫ltiplos sensores

```rust
// i2c_communication.rs
use arduino_hal::i2c::I2c;
use arduino_hal::prelude::*;

pub struct I2CSensorManager {
    i2c: I2c<arduino_hal::pac::TWI>,
    sensor_addresses: [u8; 4],
}

impl I2CSensorManager {
    pub fn new() -> Self {
        let dp = arduino_hal::Peripherals::take().unwrap();
        let pins = arduino_hal::pins!(dp);
        
        let i2c = arduino_hal::I2c::new(
            dp.TWI,
            pins.a4.into_pull_up_input(),
            pins.a5.into_pull_up_input(),
            100000, // 100kHz
        );
        
        Self {
            i2c,
            sensor_addresses: [0x48, 0x49, 0x4A, 0x4B], // Endere√ßos exemplo
        }
    }
    
    pub fn scan_devices(&mut self) -> Vec<u8> {
        let mut found_devices = Vec::new();
        
        for address in 0..128 {
            let result = self.i2c.write(address, &[]);
            if result.is_ok() {
                found_devices.push(address);
            }
        }
        
        found_devices
    }
    
    pub fn read_sensor(&mut self, address: u8, register: u8) -> Result<u16, I2CError> {
        let mut buffer = [0u8; 2];
        
        // Escrever endere√ßo do registro
        self.i2c.write(address, &[register])?;
        
        // Ler dados
        self.i2c.read(address, &mut buffer)?;
        
        Ok(((buffer[0] as u16) << 8) | (buffer[1] as u16))
    }
    
    pub fn read_all_sensors(&mut self) -> Vec<SensorReading> {
        let mut readings = Vec::new();
        
        for &address in &self.sensor_addresses {
            if let Ok(value) = self.read_sensor(address, 0x00) {
                readings.push(SensorReading {
                    address,
                    value,
                    timestamp: arduino_hal::time::millis(),
                });
            }
        }
        
        readings
    }
}

pub struct SensorReading {
    pub address: u8,
    pub value: u16,
    pub timestamp: u32,
}

#[derive(Debug)]
pub enum I2CError {
    WriteError,
    ReadError,
    Timeout,
}

impl From<arduino_hal::i2c::Error> for I2CError {
    fn from(_: arduino_hal::i2c::Error) -> Self {
        I2CError::WriteError
    }
}
```

## üõ†Ô∏è **Projeto Acad√™mico: Esta√ß√£o Meteorol√≥gica**

### **Objetivo**
Desenvolver uma esta√ß√£o meteorol√≥gica completa com Arduino e Rust.

### **Funcionalidades**
- ‚úÖ Medi√ß√£o de temperatura, umidade, press√£o
- ‚úÖ An√°lise de qualidade do ar
- ‚úÖ Comunica√ß√£o serial com computador
- ‚úÖ Armazenamento de dados em EEPROM
- ‚úÖ Sistema de alertas
- ‚úÖ Calibra√ß√£o de sensores

### **Estrutura do Projeto**
```
estacao-meteorologica/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îú‚îÄ‚îÄ sensors/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ temperature.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ humidity.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pressure.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ air_quality.rs
‚îÇ   ‚îú‚îÄ‚îÄ communication/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ serial.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ i2c.rs
‚îÇ   ‚îú‚îÄ‚îÄ storage/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ eeprom.rs
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ calibration.rs
‚îÇ       ‚îî‚îÄ‚îÄ alerts.rs
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ README.md
```

## üéØ **Atividades Acad√™micas**

### **Atividade 1: An√°lise de Performance**
- Medir tempo de resposta dos sensores
- Comparar com implementa√ß√£o em C
- Analisar consumo de mem√≥ria

### **Atividade 2: Calibra√ß√£o de Sensores**
- Implementar algoritmo de calibra√ß√£o
- Analisar precis√£o e acur√°cia
- Documentar procedimentos

### **Atividade 3: Sistema de Comunica√ß√£o**
- Desenvolver protocolo customizado
- Implementar checksum e valida√ß√£o
- Testar robustez da comunica√ß√£o

## üìä **M√©tricas de Avalia√ß√£o**

### **Implementa√ß√£o (50%)**
- Funcionalidade correta
- C√≥digo limpo e documentado
- Tratamento de erros
- Otimiza√ß√£o de recursos

### **Pesquisa (30%)**
- An√°lise de dados
- Compara√ß√£o com trabalhos relacionados
- Metodologia cient√≠fica
- Conclus√µes fundamentadas

### **Apresenta√ß√£o (20%)**
- Clareza na exposi√ß√£o
- Demonstra√ß√£o pr√°tica
- Resposta a questionamentos
- Qualidade do relat√≥rio

---

**Pr√≥ximo M√≥dulo**: [M√≥dulo 4: ESP32 e IoT](../modulo-04-esp32-iot/README.md)

---

**Desenvolvido com ‚ù§Ô∏è para a comunidade acad√™mica brasileira**

*ETEC Bento Quirino - Curso Acad√™mico de Rust para Sistemas Embarcados*
