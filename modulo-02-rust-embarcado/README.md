# ‚ö° M√≥dulo 2: Rust no Contexto Embarcado

## üéØ **Objetivos de Aprendizagem Acad√™mica**

Ao final deste m√≥dulo, voc√™ ser√° capaz de:
- ‚úÖ Compreender o modelo `no_std` do Rust
- ‚úÖ Implementar memory safety em ambientes restritos
- ‚úÖ Trabalhar com interrup√ß√µes e concorr√™ncia
- ‚úÖ Desenvolver sistemas de gerenciamento de mem√≥ria
- ‚úÖ Implementar abstra√ß√µes de hardware seguras
- ‚úÖ Analisar trade-offs entre seguran√ßa e performance

## üìã **Pr√©-requisitos**

### **Obrigat√≥rios**
- ‚úÖ Conhecimento b√°sico de Rust
- ‚úÖ Conceitos de sistemas embarcados
- ‚úÖ Familiaridade com microcontroladores
- ‚úÖ Conhecimento de programa√ß√£o em C/C++

### **Recomendados**
- ‚úÖ Experi√™ncia com `no_std` programming
- ‚úÖ Conhecimento de assembly b√°sico
- ‚úÖ Familiaridade com debugging
- ‚úÖ Experi√™ncia com sistemas em tempo real

### **Recursos de Aprendizado**
- üìö [The Rust Programming Language](https://doc.rust-lang.org/book/)
- üîß [Rust Embedded Book](https://docs.rust-embedded.org/book/)
- ‚ö° [Embedded Rust Discovery](https://docs.rust-embedded.org/discovery/)

## üìö **Conte√∫do Te√≥rico Acad√™mico**

### **üìã √çndice do M√≥dulo**
- [2.1 Introdu√ß√£o ao no_std](#21-introdu√ß√£o-ao-no_std)
- [2.2 Memory Safety em Embarcados](#22-memory-safety-em-embarcados)
- [2.3 Sistema de Interrup√ß√µes](#23-sistema-de-interrup√ß√µes)
- [2.4 Gerenciamento de Mem√≥ria](#24-gerenciamento-de-mem√≥ria)
- [Exemplos Pr√°ticos](#exemplos-pr√°ticos-acad√™micos)
- [Projeto Acad√™mico](#projeto-acad√™mico-sistema-cr√≠tico-em-tempo-real)
- [Atividades Acad√™micas](#atividades-acad√™micas)

---

### **2.1 Introdu√ß√£o ao no_std**

#### **Conceitos Fundamentais**
```rust
#![no_std]  // Sem biblioteca padr√£o
#![no_main] // Sem fun√ß√£o main padr√£o
#![feature(start)] // Feature para entry point

// Sem heap allocation
// Sem std::collections
// Sem std::thread
// Sem std::sync
```

#### **Vantagens do no_std**
- **Controle Total**: Acesso direto ao hardware
- **Previsibilidade**: Sem garbage collection
- **Performance**: Sem overhead de runtime
- **Seguran√ßa**: Memory safety mantida

### **2.2 Memory Safety em Embarcados**

#### **Ownership em Sistemas Cr√≠ticos**
```rust
// ownership_embarcado.rs
pub struct CriticalResource {
    data: [u8; 1024],
    is_initialized: bool,
}

impl CriticalResource {
    pub fn new() -> Self {
        Self {
            data: [0; 1024],
            is_initialized: false,
        }
    }
    
    pub fn initialize(&mut self) -> Result<(), CriticalError> {
        if self.is_initialized {
            return Err(CriticalError::AlreadyInitialized);
        }
        
        // Inicializa√ß√£o segura
        for i in 0..self.data.len() {
            self.data[i] = i as u8;
        }
        
        self.is_initialized = true;
        Ok(())
    }
    
    pub fn read_data(&self, index: usize) -> Result<u8, CriticalError> {
        if !self.is_initialized {
            return Err(CriticalError::NotInitialized);
        }
        
        if index >= self.data.len() {
            return Err(CriticalError::IndexOutOfBounds);
        }
        
        Ok(self.data[index])
    }
    
    pub fn write_data(&mut self, index: usize, value: u8) -> Result<(), CriticalError> {
        if !self.is_initialized {
            return Err(CriticalError::NotInitialized);
        }
        
        if index >= self.data.len() {
            return Err(CriticalError::IndexOutOfBounds);
        }
        
        self.data[index] = value;
        Ok(())
    }
}

#[derive(Debug)]
pub enum CriticalError {
    NotInitialized,
    AlreadyInitialized,
    IndexOutOfBounds,
    MemoryError,
}
```

#### **Borrowing em Contextos de Interrup√ß√£o**
```rust
// borrowing_interrupts.rs
use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};
use core::cell::UnsafeCell;

// Dados compartilhados entre interrup√ß√£o e main loop
pub struct SharedData {
    counter: AtomicU32,
    flag: AtomicBool,
    buffer: UnsafeCell<[u8; 256]>,
}

unsafe impl Sync for SharedData {}

impl SharedData {
    pub fn new() -> Self {
        Self {
            counter: AtomicU32::new(0),
            flag: AtomicBool::new(false),
            buffer: UnsafeCell::new([0; 256]),
        }
    }
    
    pub fn increment_counter(&self) {
        self.counter.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn set_flag(&self, value: bool) {
        self.flag.store(value, Ordering::Relaxed);
    }
    
    pub fn is_flag_set(&self) -> bool {
        self.flag.load(Ordering::Relaxed)
    }
    
    pub fn get_counter(&self) -> u32 {
        self.counter.load(Ordering::Relaxed)
    }
    
    pub fn write_buffer(&self, index: usize, value: u8) -> Result<(), CriticalError> {
        if index >= 256 {
            return Err(CriticalError::IndexOutOfBounds);
        }
        
        unsafe {
            (*self.buffer.get())[index] = value;
        }
        
        Ok(())
    }
    
    pub fn read_buffer(&self, index: usize) -> Result<u8, CriticalError> {
        if index >= 256 {
            return Err(CriticalError::IndexOutOfBounds);
        }
        
        Ok(unsafe { (*self.buffer.get())[index] })
    }
}
```

### **2.3 Sistema de Interrup√ß√µes**

#### **Gerenciador de Interrup√ß√µes**
```rust
// interrupt_manager.rs
use core::sync::atomic::{AtomicU32, Ordering};

pub struct InterruptManager {
    interrupt_counters: [AtomicU32; 8],
    interrupt_enabled: [AtomicBool; 8],
}

impl InterruptManager {
    pub fn new() -> Self {
        Self {
            interrupt_counters: [
                AtomicU32::new(0), AtomicU32::new(0),
                AtomicU32::new(0), AtomicU32::new(0),
                AtomicU32::new(0), AtomicU32::new(0),
                AtomicU32::new(0), AtomicU32::new(0),
            ],
            interrupt_enabled: [
                AtomicBool::new(false), AtomicBool::new(false),
                AtomicBool::new(false), AtomicBool::new(false),
                AtomicBool::new(false), AtomicBool::new(false),
                AtomicBool::new(false), AtomicBool::new(false),
            ],
        }
    }
    
    pub fn enable_interrupt(&self, interrupt_id: usize) {
        if interrupt_id < 8 {
            self.interrupt_enabled[interrupt_id].store(true, Ordering::Relaxed);
        }
    }
    
    pub fn disable_interrupt(&self, interrupt_id: usize) {
        if interrupt_id < 8 {
            self.interrupt_enabled[interrupt_id].store(false, Ordering::Relaxed);
        }
    }
    
    pub fn handle_interrupt(&self, interrupt_id: usize) {
        if interrupt_id < 8 && self.interrupt_enabled[interrupt_id].load(Ordering::Relaxed) {
            self.interrupt_counters[interrupt_id].fetch_add(1, Ordering::Relaxed);
        }
    }
    
    pub fn get_interrupt_count(&self, interrupt_id: usize) -> u32 {
        if interrupt_id < 8 {
            self.interrupt_counters[interrupt_id].load(Ordering::Relaxed)
        } else {
            0
        }
    }
}

// Macros para definir handlers de interrup√ß√£o
#[macro_export]
macro_rules! interrupt_handler {
    ($name:ident, $id:expr) => {
        #[no_mangle]
        pub extern "C" fn $name() {
            INTERRUPT_MANAGER.handle_interrupt($id);
        }
    };
}

// Exemplo de uso
interrupt_handler!(timer0_interrupt, 0);
interrupt_handler!(uart_interrupt, 1);
interrupt_handler!(adc_interrupt, 2);
```

### **2.4 Gerenciamento de Mem√≥ria**

#### **Allocator Personalizado**
```rust
// custom_allocator.rs
use core::alloc::{GlobalAlloc, Layout};
use core::ptr::NonNull;

pub struct EmbeddedAllocator {
    heap_start: *mut u8,
    heap_end: *mut u8,
    current_ptr: *mut u8,
}

unsafe impl Sync for EmbeddedAllocator {}

impl EmbeddedAllocator {
    pub const fn new(heap_start: *mut u8, heap_size: usize) -> Self {
        Self {
            heap_start,
            heap_end: unsafe { heap_start.add(heap_size) },
            current_ptr: heap_start,
        }
    }
    
    pub fn used_memory(&self) -> usize {
        unsafe { self.current_ptr.offset_from(self.heap_start) as usize }
    }
    
    pub fn available_memory(&self) -> usize {
        unsafe { self.heap_end.offset_from(self.current_ptr) as usize }
    }
}

unsafe impl GlobalAlloc for EmbeddedAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let align = layout.align();
        let size = layout.size();
        
        // Alinhar ponteiro
        let aligned_ptr = (self.current_ptr as usize + align - 1) & !(align - 1);
        let aligned_ptr = aligned_ptr as *mut u8;
        
        // Verificar se h√° mem√≥ria suficiente
        if aligned_ptr.add(size) > self.heap_end {
            return core::ptr::null_mut();
        }
        
        // Atualizar ponteiro atual
        self.current_ptr = aligned_ptr.add(size);
        
        aligned_ptr
    }
    
    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {
        // Em sistemas embarcados simples, n√£o fazemos dealloca√ß√£o
        // A mem√≥ria √© liberada apenas no reset
    }
}

// Uso do allocator
#[global_allocator]
static ALLOCATOR: EmbeddedAllocator = EmbeddedAllocator::new(
    unsafe { core::ptr::null_mut() }, // Ser√° configurado no startup
    8192 // 8KB de heap
);
```

## üíª **Exemplos Pr√°ticos Acad√™micos**

### **Exemplo 1: Sistema de Gerenciamento de Recursos**

**Objetivo de Pesquisa**: Implementar sistema seguro de gerenciamento de recursos

```rust
// resource_manager.rs
pub struct ResourceManager {
    resources: [Option<Resource>; 16],
    allocation_map: [bool; 16],
}

#[derive(Debug, Clone)]
pub struct Resource {
    id: u8,
    priority: u8,
    memory_size: usize,
    is_critical: bool,
}

impl ResourceManager {
    pub fn new() -> Self {
        Self {
            resources: [None; 16],
            allocation_map: [false; 16],
        }
    }
    
    pub fn allocate_resource(&mut self, resource: Resource) -> Result<u8, ResourceError> {
        // Encontrar slot livre
        for i in 0..16 {
            if !self.allocation_map[i] {
                self.resources[i] = Some(resource);
                self.allocation_map[i] = true;
                return Ok(i as u8);
            }
        }
        
        Err(ResourceError::NoAvailableSlots)
    }
    
    pub fn deallocate_resource(&mut self, id: u8) -> Result<(), ResourceError> {
        if id >= 16 {
            return Err(ResourceError::InvalidId);
        }
        
        if !self.allocation_map[id as usize] {
            return Err(ResourceError::NotAllocated);
        }
        
        self.resources[id as usize] = None;
        self.allocation_map[id as usize] = false;
        
        Ok(())
    }
    
    pub fn get_resource(&self, id: u8) -> Result<&Resource, ResourceError> {
        if id >= 16 {
            return Err(ResourceError::InvalidId);
        }
        
        self.resources[id as usize].as_ref()
            .ok_or(ResourceError::NotAllocated)
    }
    
    pub fn get_resource_usage(&self) -> ResourceUsage {
        let allocated = self.allocation_map.iter().filter(|&&x| x).count();
        let total_memory: usize = self.resources.iter()
            .filter_map(|r| r.as_ref())
            .map(|r| r.memory_size)
            .sum();
        
        ResourceUsage {
            allocated_resources: allocated,
            total_memory_used: total_memory,
            available_slots: 16 - allocated,
        }
    }
}

#[derive(Debug)]
pub enum ResourceError {
    NoAvailableSlots,
    InvalidId,
    NotAllocated,
    InsufficientMemory,
}

#[derive(Debug)]
pub struct ResourceUsage {
    pub allocated_resources: usize,
    pub total_memory_used: usize,
    pub available_slots: usize,
}
```

### **Exemplo 2: Sistema de Scheduler em Tempo Real**

**Objetivo de Pesquisa**: Implementar scheduler determin√≠stico para sistemas cr√≠ticos

```rust
// real_time_scheduler.rs
use core::sync::atomic::{AtomicU32, Ordering};

pub struct RealTimeScheduler {
    tasks: [Option<Task>; 8],
    current_task: AtomicU32,
    system_tick: AtomicU32,
}

#[derive(Debug, Clone)]
pub struct Task {
    pub id: u8,
    pub priority: u8,
    pub period: u32,
    pub deadline: u32,
    pub execution_time: u32,
    pub last_execution: u32,
    pub is_periodic: bool,
}

impl RealTimeScheduler {
    pub fn new() -> Self {
        Self {
            tasks: [None; 8],
            current_task: AtomicU32::new(0),
            system_tick: AtomicU32::new(0),
        }
    }
    
    pub fn add_task(&mut self, task: Task) -> Result<u8, SchedulerError> {
        // Encontrar slot livre
        for i in 0..8 {
            if self.tasks[i].is_none() {
                self.tasks[i] = Some(task);
                return Ok(i as u8);
            }
        }
        
        Err(SchedulerError::NoAvailableSlots)
    }
    
    pub fn remove_task(&mut self, task_id: u8) -> Result<(), SchedulerError> {
        if task_id >= 8 {
            return Err(SchedulerError::InvalidTaskId);
        }
        
        if self.tasks[task_id as usize].is_none() {
            return Err(SchedulerError::TaskNotFound);
        }
        
        self.tasks[task_id as usize] = None;
        Ok(())
    }
    
    pub fn schedule(&mut self) -> Option<u8> {
        let current_time = self.system_tick.load(Ordering::Relaxed);
        let mut highest_priority = 0;
        let mut selected_task = None;
        
        // Rate Monotonic Scheduling
        for (i, task_opt) in self.tasks.iter().enumerate() {
            if let Some(task) = task_opt {
                if task.is_periodic && (current_time - task.last_execution) >= task.period {
                    if task.priority > highest_priority {
                        highest_priority = task.priority;
                        selected_task = Some(i as u8);
                    }
                }
            }
        }
        
        if let Some(task_id) = selected_task {
            if let Some(task) = &mut self.tasks[task_id as usize] {
                task.last_execution = current_time;
            }
        }
        
        selected_task
    }
    
    pub fn tick(&self) {
        self.system_tick.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn check_deadline_miss(&self, task_id: u8) -> bool {
        if task_id >= 8 {
            return false;
        }
        
        if let Some(task) = &self.tasks[task_id as usize] {
            let current_time = self.system_tick.load(Ordering::Relaxed);
            let elapsed = current_time - task.last_execution;
            return elapsed > task.deadline;
        }
        
        false
    }
    
    pub fn get_system_load(&self) -> f32 {
        let total_utilization: f32 = self.tasks.iter()
            .filter_map(|t| t.as_ref())
            .map(|task| task.execution_time as f32 / task.period as f32)
            .sum();
        
        total_utilization * 100.0
    }
}

#[derive(Debug)]
pub enum SchedulerError {
    NoAvailableSlots,
    InvalidTaskId,
    TaskNotFound,
    DeadlineMiss,
    SystemOverload,
}
```

## üõ†Ô∏è **Projeto Acad√™mico: Sistema Cr√≠tico em Tempo Real**

### **Objetivo**
Desenvolver um sistema cr√≠tico em tempo real com garantias de seguran√ßa e determinismo.

### **Funcionalidades**
- ‚úÖ Gerenciamento seguro de recursos
- ‚úÖ Scheduler determin√≠stico
- ‚úÖ Sistema de interrup√ß√µes robusto
- ‚úÖ Memory safety garantida
- ‚úÖ An√°lise de performance em tempo real

### **Estrutura do Projeto**
```
sistema-critico/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îú‚îÄ‚îÄ scheduler/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ real_time.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ priority.rs
‚îÇ   ‚îú‚îÄ‚îÄ memory/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ allocator.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ manager.rs
‚îÇ   ‚îú‚îÄ‚îÄ interrupts/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handler.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ manager.rs
‚îÇ   ‚îî‚îÄ‚îÄ safety/
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ       ‚îú‚îÄ‚îÄ watchdog.rs
‚îÇ       ‚îî‚îÄ‚îÄ checks.rs
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ README.md
```

## üéØ **Atividades Acad√™micas**

### **Atividade 1: An√°lise de Memory Safety**
- Implementar sistema de detec√ß√£o de vazamentos
- Comparar com sistemas em C
- Medir overhead de seguran√ßa

### **Atividade 2: Otimiza√ß√£o de Performance**
- Implementar profiling em tempo real
- Analisar lat√™ncia de interrup√ß√µes
- Otimizar scheduler para determinismo

### **Atividade 3: Valida√ß√£o Formal**
- Implementar verifica√ß√µes est√°ticas
- Usar ferramentas de an√°lise formal
- Documentar garantias de seguran√ßa

## üìä **M√©tricas de Avalia√ß√£o**

### **Implementa√ß√£o (50%)**
- Corre√ß√£o da implementa√ß√£o
- Seguran√ßa de mem√≥ria
- Performance e determinismo
- Tratamento de erros

### **Pesquisa (30%)**
- An√°lise comparativa
- Metodologia cient√≠fica
- Documenta√ß√£o t√©cnica
- Conclus√µes fundamentadas

### **Apresenta√ß√£o (20%)**
- Demonstra√ß√£o pr√°tica
- Clareza na exposi√ß√£o
- Resposta a questionamentos
- Qualidade do relat√≥rio

---

## üß≠ **Navega√ß√£o**

### **üìö Material de Apoio**
- [**README Principal**](../../README.md) - Vis√£o geral do curso
- [**Tutoriais Detalhados**](../../TUTORIAIS.md) - Guia completo de tutoriais
- [**M√≥dulo 1: Fundamentos**](../modulo-01-fundamentos-embarcados/README.md) - M√≥dulo anterior
- [**M√≥dulo 3: Arduino**](../modulo-03-arduino-rust/README.md) - Pr√≥ximo m√≥dulo

### **üîó Links √öteis**
- [Rust Embedded Working Group](https://github.com/rust-embedded/wg)
- [Arduino Rust Community](https://github.com/Rahix/avr-hal)
- [ESP32 Rust Community](https://github.com/esp-rs)

### **üìñ Documenta√ß√£o Oficial**
- [The Rust Programming Language](https://doc.rust-lang.org/book/)
- [Rust Embedded Book](https://docs.rust-embedded.org/book/)
- [Embedded Rust Discovery](https://docs.rust-embedded.org/discovery/)

---

**Pr√≥ximo M√≥dulo**: [M√≥dulo 3: Arduino com Rust](../modulo-03-arduino-rust/README.md)

---

**Desenvolvido com ‚ù§Ô∏è para a comunidade acad√™mica brasileira**

*ETEC Bento Quirino - Curso Acad√™mico de Rust para Sistemas Embarcados*
